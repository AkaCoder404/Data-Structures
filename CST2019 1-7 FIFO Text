CST2019 1-7 FIFO
题目描述

在计算机运行过程中经常要涉及“调度”的问题，“访存”就是一个很好的例子，接下来我们将以此为例介绍一个简化版的 FIFO 调度算法。

我们的程序当中会有大量操作涉及到“访存”，比如一条语句x = a[i]就代表读取地址为a + i的内存单元的值，而访存是相当慢的，因此计算机往往会有一个相对较小“缓冲器”，将最近访问过的地址及其对应值记录下来（缓冲器的每个元素为一个数对，分别代表访存地址和地址上的值）。在涉及到访存时，先在该缓冲器里查找，如果找到了就直接用缓冲器的结果作为答案，否则再通过查找内存得到结果。

FIFO 是一种较为简单的调度策略，我们来描述一下其过程：

1、当要访问某个地址的值时，会先在缓冲器里寻找该地址及其对应值

2、若在缓冲器中找到该地址，则将其对应值返回，操作结束

3、若未找到该地址，则从内存中读取该地址对应值，并试图将该地址及其对应值存到缓冲器中

4、若缓冲器暂时没有满，则直接存下来，操作结束

5、若缓冲器已经满了，则找到最先进入缓冲器的元素，将它从缓冲器中删除，并将空缺的位置由当前访问地址及其值代替

刚开始缓冲器为空，现在有一系列访存请求，我们想知道使用该调度算法的前提下，会有几次需要去内存中访存。
输入

输入第一行有两个正整数 n, m。n 代表缓冲器的大小，m 代表访存次数。

接下来一行有 m 个正整数，分别代表每次访问的地址。在这里我们将问题做了简化，每个地址一定是 1 到 100 间的整数。
输出

输出一个整数表示答案
输入样例

3 7
1 2 1 5 4 4 1

输出样例

5

样例解释

刚开始时缓冲器为空。

首先访问 1，无法在缓冲器中找到，去内存中查找，目前访存了 1 次。缓冲器现在内容为1。

接着访问 2，无法在缓冲器中找到，去内存中查找，目前访存了 2 次。缓冲器现在内容为1 2。

接着访问 1，可以在缓冲器中找到。

接着访问 5，无法在缓冲器中找到，去内存中查找，目前访存了 3 次。缓冲器现在内容为1 2 5。

接着访问 4，无法在缓冲器中找到，去内存中查找，目前访存了 4 次。由于缓冲器已满，故根据算法流程，我们找到最先进入缓冲器的1，将它用4替代，缓冲器现在内容为4 2 5。

接着访问 4，可以在缓冲器中找到。

接着访问 1，无法在缓冲器中找到，去内存中查找，目前访存了 5 次。由于缓冲器已满，故根据算法流程，我们找到最先进入缓冲器的2，将它用1替代，缓冲器现在内容为4 1 5。
数据范围

1 <= n <= 100

1 <= m <= 1000

1 <= 内存地址 <= 100
资源限制

时间限制：0.5 sec

空间限制：256 MB
提示

　　● [队列]
UI powered by Twitter Bootstrap.
Tsinghua Online Judge is designed and coded by Li Ruizhe.
For all suggestions and bug reports, contact oj[at]liruizhe[dot]org.
