描述
  - 用户系统保存密码时，不能明文保存（为什么？），一种做法是加盐 hash。具体地，对于密码 password 和盐 salt，会将 password + salt 的 CRC32 值存在数据库里。当用户登录时，重复此计算，验证 hash 值是否相等。比如 password 为 "123"，salt 为 "thu"，那么我们存储的是 "123thu" 的 CRC32 值。
  - 这个用户系统规定，密码和盐必须由 0123456789tsinghua 中的字符组成，密码长度和盐的长度都大于等于 1。为了简单起见，所有用户使用相同的盐。
  - 现在，小 Y 窃听了一些密文，他想破解密文对应的密码。由于破解的计算量太大，一开始他只准备破解不超过 5 位的密码。此外，他认为任意连续 r（r <= 8）个成功破解的明文的首字母相连是弱口令；他不断地把弱口令加入他的破解目标。
  - 总的来说，在破解第 i（0 <= i < n）条密文时，小 Y 的字典里有所有不超过 5 位的密码，以及从第 [0, i) 条密文里发现的弱口令。如果该密文匹配字典里唯一明文，输出这个明文；如果不在字典里，输出No；如果匹配多个明文，输出Duplicate。计算弱口令时忽略 Duplicate 的项，例如如果连续 8 个破解结果是 1、22、333、No、Duplicate、tttt、hhhhh、uuuuuu，那么 123thu 是一个弱口令。
  - 我们提供了 CRC32 的计算文件 crc32.zip，通过 #include "crc32.h" 引用，调用 crc32(0, buf, len) 计算 buf 的 CRC32 值。你也可以不使用我们提供的 crc32 函数，使用与否不影响评分。OJ 评测时，请不要提交该压缩包中的文件，我们会在评测时为你自动加入该文件，重复提交可能导致函数重定义的编译错误。

输入
　　- 第 1 行为 n。
　　- 第 2 行为盐。
　　- 接下来 n 行，每行是一个 CRC32 值，是字符串长度为 8 的小写十六进制数，对应小 Y 窃听到的一个密文。
输出
　　共 n 行，每行对应一条密文的破解结果。

输入样例
-------------------------------
11
thu
094dca7d
46730bd8
00000000
a3162b22
75426c9c
594da650
cbb32701
d74db8e2
094dca7d
dcb0ffb7
9a4ab472
-------------------------------
　　*此样例是第 1 个测试点。

输出样例
-------------------------------
4thin
666
No
u
uu
uuu
uuuu
uuuuu
Duplicate
12345
6uuuuu1
-------------------------------
　　样例解释：第二次破解 094dca7d 时，CRC32("4thin" + salt) == CRC32("6uuuuu" + salt) == 0x094dca7d，故为 Duplicate。

数据范围
    - 1 <= n <= 1,000,000
　　- 1 <= 盐的长度 <= 4

资源限制
　　- 时间限制：2 sec
    - 空间限制：256 MB

提示
    - 散列
    - [ CRC32 是流式函数：将 buf1 的 CRC32 值作为初始值，计算 buf2 的 CRC32 值，将得到 buf1 + buf2 的 CRC32 值。因此你可能不需要做字符串拼接。 ]

